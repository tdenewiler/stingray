DESCRIPTION:
The Stingray runs multiple programs at once and each of those programs performs a specific task such as running the control loops, planning, vision processing, battery monitoring, data logging and providing an operator interface. Not all of these programs are necessarily running at the same time but for minimal operation multiple programs do have to run simultaneously and share data with one another in a reasonably fast manner. To accomplish this sharing of data the team has developed a messaging system that runs on a network layer -- currently we are only using TCP but would like to expand this to have the option of using UDP in the future. In addition to the programs listed above that need to share data the idea of using a networked messaging system also allows other developers to write their own applications to perform tasks using the Stingray if they can use the same networking and message protocol that we have already developed.

The networking and messaging code we currenlty use was written a couple of years ago and it includes a few hacks that have become necessary as the code has grown and we want to get those hacks removed. One way to do that is to find and fix the bugs in the current code while another approach would be to get the Boost libraries to work (see http://www.boost.org/ for more information about that). Several years ago the documentation for the Boost libraries was rubbish but more and more groups are using them lately so maybe the situation has improved (or maybe I just didn't really know what I was looking at back then). The primary goal is to create a library that allows us to send arbitrary data over network connections, either by fixing our code or using a third-party solution like Boost, with a secondary goal being to convert the code into libraries for networking and messaging (currently we have to compile this code with each of our main programs and not link to it as a library because the network and message code is very intertwined).


COMPILING AND RUNNING:
This directory contains a simple test case for our networking and messaging code, based on code that we actually use. For reference we do all of our development using Ubuntu Linux (any version should work, 32-bit or 64-bit) on x86 or x86-64 CPUs although other versions of Linux should work as well as we are only using standard system libraries. Also, most of us use Geany as our editor and IDE (integrated development environment) but that is a personal preference and I can give a little run-down of how Geany is used if desired. To compile this code only g++, make and the standard C libaries that come with Ubuntu are required but you may also want to install Geany and can be installed with the command

sudo apt-get install build-essential geany

To compile this code run the command `make' in the libs/timing/ directory to generate the timing library and then run `make' in this directory to generate the programs server and client. To run this code use two terminals and run `./server' in one and `./client' in the other and you should see both programs run and print out some debugging information to let you know what their status is.
 

ISSUES:
1) Right now I have to send a keep-alive message from all the clients to any servers they are connected to. I would rather it work such that clients and servers just stay open even when they aren't connected to anyone but that they periodically try to re-establish communications while maybe having a timeout after 2-3 minutes.
2) Currently I have only implemented TCP but it would be nice if we could choose to use either UDP or TCP. That would be a very low priority though.
3) This goal only applies if we are trying to fix the current code base. Some of the servers and clients are sending multiple messages per cycle and I am not pulling them off the network stack and placing them in a buffer properly. Some of the data is likely being overwritten because I am not moving the pointer location to where it needs to be. That would go a long way towards fixing the current code.
4) Another problem with our code is that we currently send binary data all around. I would prefer if we could send the data as strings that would get parsed and then fill in the correct variables. This isn't a huge deal but when working with networked code it is much easier to debug with packages like EtherPeek or Wireshark if you can read the embedded data in plain-text rather than in binary.
5) I would like to look for a way to make the calls to the network library more efficient than they currently are. I don't know where in the code to look for speed improvements though.
6) One last goal would be to get the library to work with either Linux or Windows, right now our network code is *nix specific but this would be just a nice-to-have and the lowest priority. I think boost libraries are cross-platform.
7) I have included a timing library that I wrote. Right now it's not being used in this code but it can serve as an example of how to create a library and how to use it in your own code. Ideally, I would like to see the network code become a library of it's own and be completely independent of the message.c code and for that the timing library could be used as a template. I'm not sure at all how we would actually go about separating the message code from the network code and still keep things relatively simple in the programs that use call network and message functions. We can talk about that later if you get there. Also, I included the timing library so that you could use it to try and periodically re-establish a connection from client to server.

To see some of these bugs in action you can try these steps.
1) Try <ctrl-c> on client, then restart client. Try <ctrl-c> on server while client is running and you should see that client exits. That is one of the things I want to get fixed. Client should recognize that it cannot communicate with server and periodically try to re-establish a connection to server but client should not exit until <ctrl-c> is entered.
2) In client, you should see that we are receiving different numbers of bytes each cycle through the main loop of client. This is due to a hack in network.c where I am sending one message each cycle through the main loop of both server and client. I want to get rid of this hack and send an arbitrary number of messages at a time. Currently, sending more than one message causes some of the data from the first messages to get overwritten by subsequent messages.
3) If you want to try and use the Boost libraries you will probably still need to have the server and client programs, the only difference will be that where I am calling our own network code you would make calls to the Boost libraries. To get this to happen you will have to build against the Boost libraries instead of network.c -- I can help you with that if you ever get to that point.
